def solution(n, m, x, y, queries):
    answer = 0
    l, r, t, b = y, y, x, x
    
    for q in queries[::-1]:
        if q[0] == 0:
            temp = r + q[1] if r + q[1] <= m-1 else m-1
            if l == 0:
                r = temp
            else:
                l, r = l + q[1], temp
        if q[0] == 1:
            temp = l - q[1] if l - q[1] >= 0 else 0
            if r == m-1:
                l = temp
            else:
                l, r = temp, r - q[1]
        if q[0] == 2:
            temp = t + q[1] if t + q[1] <= n-1 else n-1
            if b == 0:
                t = temp
            else:
                b, t = b + q[1], temp
        if q[0] == 3:
            temp = b - q[1] if b - q[1] >= 0 else 0
            if t == n-1:
                b = temp
            else:
                b, t = temp, t - q[1]
        if l > m-1 or r < 0 or b > n-1 or t < 0:
            break
    else:
        answer = (r-l+1) * (t-b+1) 
    return answer
"""
생각해보자.
역순으로 진행했을 때, 현재 위치가 상하좌우 중 어디라도 맨 끝이면 그 반대편으로부터 차이가 최대 q[1]만큼인 어느 위치에서 출발했든 현재 위치에 도착하게 될 거다.
만약 맨 끝이 아니라면 딱 q[1]만큼 이동하기 전 위치만에서만이 현재 위치로 올 수 있었을 것이다.
따라서 왼쪽맨끝 l, 오른쪽맨끝 r, 아랫쪽맨끝 b, 윗쪽맨끝 t를 변수로 하여 각각을 움직여가며 범위를 구하여 나오는 직사각형의 어느 곳에서 출발하든 x,y로 도착하게 된다.
1. query의 [0]이 0,1,2,3 중 어느 것인지 파악
2. 각각의 경우에서 [0]이 0,1인 경우엔 l, r을, [0]이 2,3인 경우엔 b, t를 움직인다.
3. 예컨데 [0]이 0인 경우엔 왼쪽으로 [1]만큼 움직인다. 따라서 반대로 진행했을 땐 현 위치에서 [1]만큼 오른쪽으로 진행할 것이다.
    3.1 이때 현위치의 왼쪽끝이 막혀있는, 즉 0에 위치할 경우 0~[1]의 위치중 어느곳에서 왼쪽으로 [1]만큼 이동하더라도 0에 오기때문에 범위는 l = 0, r = [1]이 될 것이다.
    3.2 만약 현위치의 왼쪽끝이 막혀있지 않는, 즉 0이 아니라면 현위치+[1] 위치에서 출발해야만 현위치에 도착할 수 있다.
    3.3 이때 현위치+[1]이 격자의 범위 n x m을 벗어난다면 해당 지점으로는 도착할 수 없게 된다.
4. 위의 과정을 queries 만큼 진행하는 동안 범위가 n x m을 벗어나지 않았다면 (l,r,b,t)로 형성되는 직사각형의 범위가 정답이 된다.
"""
